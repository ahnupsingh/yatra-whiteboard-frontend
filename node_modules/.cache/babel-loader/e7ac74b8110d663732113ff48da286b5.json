{"ast":null,"code":"export const canAccess = toCheck => {\n  let predicate = perm => {\n    return perm[0] == toCheck[0] && perm[1] == toCheck[1];\n  }; // return _k.initialState.ui_permissions.data.find(predicate) !== undefined;\n\n\n  return false;\n};\nexport const deepFlatten = arr => [].concat(...arr.map(v => Array.isArray(v) ? deepFlatten(v) : v));\nexport const parseRoute = (routes, link = 'routes') => {\n  return routes.map(item => {\n    let nnav = Object.assign({}, item);\n\n    if (Array.isArray(nnav[link])) {\n      delete nnav[link];\n      return [nnav, ...parseRoute(item[link])];\n    } else {\n      return item;\n    }\n  }).filter(item => item.hasOwnProperty('accessible') ? item.accessible : true);\n};\nexport const keyToTitleCase = str => {\n  if (!str) {\n    return str;\n  }\n\n  let frags = str.split('_');\n\n  for (let i = 0; i < frags.length; i++) {\n    frags[i] = frags[i].charAt(0).toUpperCase() + frags[i].slice(1);\n  }\n\n  return frags.join(' ');\n};","map":{"version":3,"sources":["/home/anup/janakitech/minion.tom/src/misc/utils.js"],"names":["canAccess","toCheck","predicate","perm","deepFlatten","arr","concat","map","v","Array","isArray","parseRoute","routes","link","item","nnav","Object","assign","filter","hasOwnProperty","accessible","keyToTitleCase","str","frags","split","i","length","charAt","toUpperCase","slice","join"],"mappings":"AAAA,OAAO,MAAMA,SAAS,GAAIC,OAAD,IAAa;AAClC,MAAIC,SAAS,GAAIC,IAAD,IAAU;AACtB,WAAOA,IAAI,CAAC,CAAD,CAAJ,IAAWF,OAAO,CAAC,CAAD,CAAlB,IAAyBE,IAAI,CAAC,CAAD,CAAJ,IAAWF,OAAO,CAAC,CAAD,CAAlD;AACH,GAFD,CADkC,CAKlC;;;AACA,SAAO,KAAP;AACH,CAPM;AASP,OAAO,MAAMG,WAAW,GAAGC,GAAG,IAAI,GAAGC,MAAH,CAAU,GAAGD,GAAG,CAACE,GAAJ,CAAQC,CAAC,IAAKC,KAAK,CAACC,OAAN,CAAcF,CAAd,IAAmBJ,WAAW,CAACI,CAAD,CAA9B,GAAoCA,CAAlD,CAAb,CAA3B;AAEP,OAAO,MAAMG,UAAU,GAAG,CAACC,MAAD,EAASC,IAAI,GAAG,QAAhB,KAA6B;AACnD,SAAOD,MAAM,CAACL,GAAP,CAAWO,IAAI,IAAI;AACtB,QAAIC,IAAI,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBH,IAAlB,CAAX;;AACA,QAAIL,KAAK,CAACC,OAAN,CAAcK,IAAI,CAACF,IAAD,CAAlB,CAAJ,EAA+B;AAC3B,aAAOE,IAAI,CAACF,IAAD,CAAX;AACA,aAAO,CAACE,IAAD,EAAO,GAAGJ,UAAU,CAACG,IAAI,CAACD,IAAD,CAAL,CAApB,CAAP;AACH,KAHD,MAGO;AACH,aAAOC,IAAP;AACH;AACJ,GARM,EAQJI,MARI,CAQGJ,IAAI,IAAIA,IAAI,CAACK,cAAL,CAAoB,YAApB,IAAqCL,IAAI,CAACM,UAA1C,GAAwD,IARnE,CAAP;AASH,CAVM;AAYP,OAAO,MAAMC,cAAc,GAAIC,GAAD,IAAS;AACnC,MAAI,CAACA,GAAL,EAAU;AAAE,WAAOA,GAAP;AAAa;;AACzB,MAAIC,KAAK,GAAGD,GAAG,CAACE,KAAJ,CAAU,GAAV,CAAZ;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAAK,CAACG,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACnCF,IAAAA,KAAK,CAACE,CAAD,CAAL,GAAWF,KAAK,CAACE,CAAD,CAAL,CAASE,MAAT,CAAgB,CAAhB,EAAmBC,WAAnB,KAAmCL,KAAK,CAACE,CAAD,CAAL,CAASI,KAAT,CAAe,CAAf,CAA9C;AACH;;AACD,SAAON,KAAK,CAACO,IAAN,CAAW,GAAX,CAAP;AACH,CAPM","sourcesContent":["export const canAccess = (toCheck) => {\n    let predicate = (perm) => {\n        return perm[0] == toCheck[0] && perm[1] == toCheck[1]\n    }\n\n    // return _k.initialState.ui_permissions.data.find(predicate) !== undefined;\n    return false\n}\n\nexport const deepFlatten = arr => [].concat(...arr.map(v => (Array.isArray(v) ? deepFlatten(v) : v)))\n\nexport const parseRoute = (routes, link = 'routes') => {\n    return routes.map(item => {\n        let nnav = Object.assign({}, item);\n        if (Array.isArray(nnav[link])) {\n            delete nnav[link];\n            return [nnav, ...parseRoute(item[link])]\n        } else {\n            return item\n        }\n    }).filter(item => item.hasOwnProperty('accessible') ? (item.accessible) : true)\n}\n\nexport const keyToTitleCase = (str) => {\n    if (!str) { return str; }\n    let frags = str.split('_');\n    for (let i = 0; i < frags.length; i++) {\n        frags[i] = frags[i].charAt(0).toUpperCase() + frags[i].slice(1);\n    }\n    return frags.join(' ');\n}\n\n"]},"metadata":{},"sourceType":"module"}